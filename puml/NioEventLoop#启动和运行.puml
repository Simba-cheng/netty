'①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳
@startuml participant

Actor -> AbstractChannel: \n 1. register

AbstractChannel -> SingleThreadEventExecutor: \n 2. 将任务交给 NioEventLoop 处理
note right
2#
以下是调用栈顺序:
    1).SingleThreadEventExecutor.execute(java.lang.Runnable)
    2).SingleThreadEventExecutor.execute0(java.lang.Runnable)
    3).SingleThreadEventExecutor.execute(java.lang.Runnable, boolean)
end note

SingleThreadEventExecutor -> SingleThreadEventExecutor: \n 3. addTask
note right #FFE4C4
3#
将由register方法提交的任务
添加到内部队列中(taskQueue)。
end note

SingleThreadEventExecutor -> SingleThreadEventExecutor: \n 4. doStartThread
note right
4#
向内部的线程池提交<color:#FF0000>一个</color>线程,
队列中的那些任务将有这个线程取出并执行。

<color:#FF0000>此线程就是 NioEventLoop 中的工作线程。</color>
end note

group <size:14><color:#FF4500>以下逻辑都运行在第4步创建的线程中</color></size>

SingleThreadEventExecutor -> NioEventLoop: \n 5. this.run()
note left
5#
执行 SingleThreadEventExecutor 的 run() 方法,
它在 NioEventLoop 中实现了。
即: SingleThreadEventExecutor.this.run();
end note

' ----- 分割线 -----
group 'for (;;)' 死循环
    NioEventLoop -> NioEventLoop: \n ① 检查 taskQueue 任务数 \n   获取 strategy 标识
    note right
    在存在异步任务的场景,
    NioEventLoop 会优先保证CPU能够及时处理异步任务。
    end note

    group if( strategy = SelectStrategy.SELECT ) [<size:13><color:#FF8C00>即taskQueue任务队列没有任务</color></size>]
        NioEventLoop -> NioEventLoop: \n ② select(long deadlineNanos) \n    尝试轮询IO事件(就绪的channel) \n    可能会阻塞
    else 'else' <size:13><color:#FF8C00>taskQueue任务队列中有任务</color></size>

        NioEventLoop -> NioEventLoop: \n ③ processSelectedKeys() \n    IO事件处理
        group <color:#836FFF>③ processSelectedKeys 方法内逻辑</color>

            group if (selectedKeys != null) [selectedKeys 集合类型是 Netty 优化过的 SelectedSelectionKeySet]
                NioEventLoop -> NioEventLoop: \n\n (1). processSelectedKeysOptimized
                note right
                针对 Netty 优化过的 selectedKeys 集合的处理
                end note
            else selector.selectedKeys(), 此集合类型是JDK中的HashSet
                NioEventLoop -> NioEventLoop: \n\n (2).processSelectedKeysPlain
                note right
                正常处理逻辑
                end note
            end

            NioEventLoop -> NioEventLoop: \n\n (3).processSelectedKey
            note left
            (3)#
            上面不论进入 (1)分支 还是 (2)分支,
            最终调用的是 processSelectedKey 方法
            end note
            group <color:#836FFF>(3) processSelectedKey 方法内逻辑</color>
                NioEventLoop -> NioEventLoop: \n 获取 Channel 对应的 unsafe
                note right
                通过 Unsafe 处理IO事件
                end note
                NioEventLoop -> NioEventLoop: \n 处理 OP_CONNECT 事件
                NioEventLoop -> NioEventLoop: \n 处理 OP_WRITE 事件
                NioEventLoop -> NioEventLoop: \n 处理 OP_READ 事件
            end

        end

        NioEventLoop -> NioEventLoop: \n\n ④ runAllTasks()、runAllTasks(timeoutNanos) \n    执行taskQueue任务队列中的任务
        group <color:#836FFF>④ runAllTasks(timeoutNanos) 方法内逻辑</color>
            NioEventLoop -> NioEventLoop: \n\n 合并任务
                note right
                从 定时任务队列(scheduledTaskQueue) 中取出执行时间小于当前时间的
                定时任务(scheduledTask),添加到 普通任务队列(taskQueue) 中。
                end note
            NioEventLoop -> NioEventLoop: \n\n 处理任务
                note right
                从 普通任务队列(taskQueue) 中取出任务并执行
                end note
        end
    end
end
' ----- 分割线 -----


Actor <-- NioEventLoop: \n
end
@enduml