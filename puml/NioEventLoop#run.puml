@startuml participant

Actor -> AbstractChannel: 1. register

AbstractChannel -> SingleThreadEventExecutor: 2. SingleThreadEventExecutor \n    execute(java.lang.Runnable, boolean)

SingleThreadEventExecutor -> SingleThreadEventExecutor: \n 3. addTask
note right
3#
将由register方法提交的任务
添加到内部队列中(taskQueue)。
end note

SingleThreadEventExecutor -> SingleThreadEventExecutor: \n 4. doStartThread
note right
4#
向内部的线程池提交一个线程,
队列中的那些任务将有这个线程取出并执行,
此线程就是 NioEventLoop 中的工作线程。
executor.execute(new Runnable(){ ... })

<color:#FF0000>注意,以下逻辑都运行在第4步创建的线程中</color>
end note

group

SingleThreadEventExecutor -> NioEventLoop: \n 5. run 即:this.run()
note left
5#
执行 SingleThreadEventExecutor 的 run() 方法，
它在 NioEventLoop 中实现了。
即: SingleThreadEventExecutor.this.run();
end note

' ----- 分割线 -----
loop 'for (;;)' 死循环
    NioEventLoop -> NioEventLoop: \n 1 检查 taskQueue 任务数

    alt 没有任务
        NioEventLoop -> NioEventLoop: \n 2 select(long deadlineNanos) \n    尝试轮询IO事件(就绪的channel) \n    可能会阻塞
    else 有任务
        NioEventLoop -> NioEventLoop: \n 3 processSelectedKeys
        NioEventLoop -> NioEventLoop: \n 3.1 处理 OP_CONNECT 事件(建立连接事件)
        NioEventLoop -> NioEventLoop: \n 3.2 处理 OP_WRITE 事件(写事件)
        NioEventLoop -> NioEventLoop: \n 3.3 处理 OP_READ 事件(读事件)

        NioEventLoop -> NioEventLoop: \n 4 runAllTasks
    end
end
' ----- 分割线 -----


SingleThreadEventExecutor <-- NioEventLoop
end
@enduml